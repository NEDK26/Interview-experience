# 设计模式

[设计模式](https://so.csdn.net/so/search?q=设计模式&spm=1001.2101.3001.7020)是在软件设计中常见问题的解决方案的通用模板或指南。它们提供了一套经过验证的方法，用于解决特定类型的问题，帮助开发人员构建出更可靠、可维护和可扩展的软件系统。设计模式不是代码片段，而是一种抽象的概念，用于指导如何组织代码、解耦组件、处理变化等。

可重用性： 设计模式提供了经过测试和验证的解决方案，可以在不同的项目和场景中重复使用，避免重复造轮子，提高开发效率。
可维护性： 设计模式可以使代码更加结构化、清晰，并将不同的关注点分离开来。这样可以减少代码之间的耦合，使得系统更容易维护和修改。
可扩展性： 设计模式可以帮助设计出灵活的架构，使得系统能够更容易地进行扩展，适应变化和需求的演变。
共享经验： 设计模式是在实践中总结出的最佳实践，通过使用它们，可以共享其他开发者的经验和智慧。
提高沟通： 设计模式提供了一种共同的词汇和理念，使得团队成员之间更容易沟通和理解代码的结构和设计。

SOLID原则

S single 单一职责 就一个类而言，应该仅有一个引起它变化的原因。

O open 开闭原则 装饰器模式 被装饰器不能被修改 装饰部分对外可以拓展 软件中的对象（类、模块、函数等）应该对于拓展是开放的，而对于修改是封闭的。

L 里氏原则 子类重写父类方法时 不能改变父类的功能

I interface 接口隔离 接口功能不能大而全 会造成冗余

D DAO 依赖倒置 高层代码依赖低层的实现，底层不能依赖高层 业务层类不应依赖具体实现的类

---

（1）[创建型模式](https://so.csdn.net/so/search?q=创建型模式&spm=1001.2101.3001.7020)：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。

（2）结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。

（3）行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。

----

单例模式：

- 确保类只有一个实例，提供一个全局访问点，例如Windows任务管理器

- 2种实现模式、饿汉模式，在类加载时就进行实例化、本身就安全;通过 ‘ a.getInstance()’调用
- 懒汉模式 调用时才进行实例化、效率高于饿汉模式 判断是否为空

```java
public class SecurityLazySingleton{
    private static volatile SecurityLazySingleton instance = null;
    private SecurityLazySingleton(){};
    
    public static SecurityLazySingleton getInstance(){
        if(instance == null){
			synchronized(SecurityLazySingleton.class){
                if(instance == null){
                    instance = new SecurityLazySingleton;
				}
            }
        }
        return instance;
    }
    
}
```

工厂模式

- 简单工厂模式：创建一个类用来负责创建其他类的实例，通常实现相同的接口，或者继承同一个父类，无需关注细节
- 抽象工厂模式：可以根据客户端的需求，加载特定的实例，返回的结果就是一个特定工厂的特定产品，并存在特定关系，就是把这个工厂的模式抽象出来，根据不同的种类得到不同的工厂，模式是相同的，包括产品、产品之间的关系

构造者模式

- 产品、建造者、具体建造者、指导者、客户端
- 构建和表示分离、一般用于复杂对象的构建

原型模式

- 通过clone方法复制原型，无需多创建，避免重复代码
- 一般用于需要创建多个实例的场景

适配器模式

- 适配器模式可以使得不兼容的接口能够协同工作，将现有的代码与新的接口进行适配，而不需要修改已有的代码。这样可以提高代码的复用性和[可扩展性](https://zhida.zhihu.com/search?q=可扩展性&zhida_source=entity&is_preview=1)
- 试用场景：兼容旧系统、跨平台兼容、第三方api集成
- **电子商务平台中与支付系统的集成**

桥接模式

- 一种多重继承的实现方案、在于解耦和抽象

组合模式

- **组合模式是一种设计模式，它将对象组合成树形结构以表示“部分-整体”的层次结构**
- 文件系统中的文件与文件夹、[组织机构](https://zhida.zhihu.com/search?q=组织机构&zhida_source=entity&is_preview=1)中的部门与员工、商品分类中的类别与商品

装饰器模式

- 假设有一个打印文档的功能，我们可以通过不同的装饰器来添加不同的打印效果（如彩色打印、双面打印等），而不需要修改原有的打印类
- **允许在运行时动态地扩展一个对象的功能，而不需要改变其现有结构**

外观模式

- 外观模式在日常生活中也有许多体现，比如去餐厅吃饭，我们不需要了解厨房里每个工作人员的具体职责和操作流程，只需要对服务员提出需求即可，这里的“服务员”就扮演了外观模式的角色，为我们提供了一个统一的入口来获取服务‌

享元模式

- 旨在通过共享对象来减少内存使用量并分享信息给尽可能多的相似对象。它适用于因重复而导致使用大量内存的对象，通过共享部分状态来减少内存消耗和提高系统性能
- 例如string字符串常量尺 Java会确保一个字符串常量在常量池中只有一个拷贝。

代理模式

----

### 模式区别：

代理模式：
代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。主要增强的是非主干或者说非业务性的功能

桥接模式：
桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。主要是分离接口部分和实现部分，应对两个（或多个）独立变化的维度

装饰模式：
装饰模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。主要是对原始类功能进行增强，支持多个装饰器的嵌套使用

适配器模式：

- 适配器模式是一种事后的补救策略，用来补救设计上的缺陷（比如接口不兼容）。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。主要提供跟原始类不同的接口。

策略模式

- 指定义了算法家族、分别封装起来，让它们之间可以相互替换，此模式让算法的变化不会影响到使用算法的用户。（属于行为型模式）

- 适用场景
  - 假如系统中有很多类，而他们的区别仅仅在于他们的行为不同
  - 一个系统需要动态地在几种算法中选择一种

- 优点

  - 策略模式符合开闭原则
  - 避免使用多重条件转移语句，如if...else...和switch语句

  - 使用策略模式可以提高算法的保密性和安全性

- 缺点

  - 客户端必须知道所有的策略，并且自行决定使用哪一个策略类

  - 代码中产生非常多策略类，增加维护难度

例子1：有一个课程优惠活动，优惠策略会有多种，如领优惠券抵扣、返现促销等。如果优惠策略越来越多，就可以结合

----

单一职责原则 

- 是面向对象设计中的一个重要原则，它规定一个类应该只有一个引起其变化的原因。换句话说，一个类应该仅负责一个相对独立且内聚的职责

里氏替换原则

- 它要求子类必须能够替换它们的基类。这意味着，在软件系统中，如果使用基类对象的地方能够无缝地使用其子类对象，并且不会改变原有程序的逻辑和行为，那么这个子类就符合里氏替换原则。这个原则强调了继承应当保持原有类的功能不改变，同时增加新的功能，而不是重写或删除原有功能

接口隔离原则

- 客户端不应该被迫依赖于它不需要的接口
- 这一原则强调，**一个接口应该只包含客户端真正需要的操作或方法**，而不应该包含任何多余或不必要的操作。通过将大的接口拆分成更小、更具体的接口，可以确保接口之间的关系更加松散，从而降低代码的耦合性，提高系统的可维护性和可扩展性。

依赖倒置原则（Dependence Inversion Principle）

- 是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的[耦合](https://baike.baidu.com/item/耦合/2821124?fromModule=lemma_inlink)。

迪米特原则 最少知识原则

- 这一原则强调一个对象应该对其他对象保持最少的了解，即一个对象应当仅与其直接的朋友进行通信，而不应该与不相关的对象进行不必要的交互。
- 

### Redis

1. **常见问题**

缓存穿透 缓存和数据库中**都不存在某个数据**时会发生的情况

缓存雪崩 数据大批量过期 导致大量查询直接访问数据库 导致数据库宕机 

缓存击穿 热key到期 导致数据库 宕机等问题

​	热key 访问频率高 读大于写 ------- 秒杀、热点新闻 

2. **过期策略和**

   定时过期											内存友好

   惰性过期 访问时才会判断是否删除  内存不友好 节省cpu资源

   定期过期 设置过期字典项

   定期过期和惰性过期的组合可能存在大量已过期key但未被访问，导致内存堆积，出现
   
   内存不够用 情况
   
   **内存淘汰策略**
   
   volatile-LRU **Least Recently Used**
   
   volatile - LFU Least Frequently Used
   
   volatile-ramdom'
   
   volatile-ttl
   
   allkeys-lru
   
   allkeys-lfu
   
   allkeys-ramdon
   
   noeviction
   
   
   
   
