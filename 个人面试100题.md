# 个人面试100题

**Java集合**

1. java HashMap底层

   - 基于哈希表的数据结构，用于存储键值对，通过哈希值来映射到数组的索引位置，通过数组➕链表来处理哈希冲突
   - 当链表长度超过8之后，会使用红黑树来代替链表，形成数组➕红黑树的结构来处理哈希冲突，红黑树是一种自平衡二叉树，能够将最坏情况时间复杂度从O(n)降低为O(Logn)
   - 性能提升 通过修改负载因子等方法
   - 哈希冲突 链地址法
   
2. java HashSet

   java中HashSet的底层实现是HashMap，HashSet只考虑key的值，value都指向同一个全局object常量，这样就实现了HashSet。 比较过程： 1.通过哈希算法比较哈希值 2.哈希值相等再比较equals 

---

**Java 多线程**

1. volatile关键字作用
   - 保证线程可见性 当字段被修改时，立即更新
   - 防止指令重排序（代码重排序）

2. 死锁

---

**设计模式** 

设计模式是**可复用的解决方案**，用于解决在软件开发过程中常见的设计问题，以提高代码的**可维护性、可扩展性和灵活性**

1. 单例模式：

   - 确保类只有一个实例，提供一个全局访问点，例如Windows任务管理器
   - 2种实现模式、饿汉模式，在类加载时就进行实例化、本身就安全;通过 ‘ a.getInstance()’调用
   - 懒汉模式 调用时才进行实例化、效率高于饿汉模式 判断是否为空

2. 装饰模式和代理模式
   **装饰模式**在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。主要是对原始类功能进行增强，支持多个装饰器的嵌套使用

   **代理模式**在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能**，这是它跟装饰器模式最大的不同。**主要增强的是非主干或者说非业务性的功能

3. 委派模式和策略模式

   老板（Boss）给项目经理（Leader）下达任务，项目经理会根据实际情况给每个员工派发工作任务，待员工把工作任务完成之后，再由项目经理汇报工作进度和结果给老板

   只负责任务的调度和分配任务，跟代理模式很像，可以看做是一种特殊情况下的静态代理的全权代理，但是代理模式注重过程，而委派模式注重结果。

----

**计算机网络**

6. http状态码

   **1XX** Infommational(信息性状态码)   接收的请求正在处理
   **2XX**Success(成功状态码)                   请求正常处理完毕
   **3XX** Redirection(重定向状态码)         **需要进行附加操作以完成请求**
   **4XX** Client Error(客户端错误状态码)  服务器无法处理请求
   **5xx** Server Eror(服务器错误状态码)  服务器处理请求出错

7. http header

   **请求部分**

   accept 能够接受的回应内容类型

   accept-charset

   accept-lauguage

   accept-Encoding

   Authorization 授权信息

   Cache-Control 用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令

   **响应部分**

   Connection 该浏览器想要优先使用的连接类型

   Content

   Content-Length 以八位字节数组（8 位的字节）表示的**请求体**的长度

   Content-MD5 请求体的内容的二进制 MD5 散列值，以 Base64 编码的结果

   Content-Type 请求体的多媒体类型（用于 POST 和 PUT 请求中）

   Cookie  之前由服务器通过 Set-Cookie（下文详述）发送的一个超文本传输协议 Cookie

   Date 发送该消息的日期和时间

   From 发起此请求的用户的邮件地址

   **Server**: 包含服务器的应用程序信息。

   **Location**: 用于重定向请求时的目标 URL

   **Access-Control-Allow-Origin**: 指定允许跨域访问的来源

8. get post请求

   语义（主要区别）：GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。

   幂等：GET 请求是幂等的，即多次重复执行不会改变资源的状态，而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。

   格式：GET 请求的参数通常放在 URL 中，形成查询字符串（querystring），而 POST 请求的参数通常放在请求体（body）中，可以有多种编码格式，如 application/x-www-form-urlencoded、multipart/form-data、application/json 等。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的 body 大小则没有明确的限制。不过，实际上 GET 请求也可以用 body 传输数据，只是并不推荐这样做，因为这样可能会导致一些兼容性或者语义上的问题。

   缓存：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。而 POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。

   安全性：GET 请求和 POST 请求如果使用 HTTP 协议的话，那都不安全，因为 HTTP 协议本身是明文传输的，必须使用 HTTPS 协议来加密传输数据。另外，GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中。

9. 三次握手 四次挥手

   - **一次握手**:客户端发送带有 SYN（SEQ=x） 标志的数据包 -> 服务端，然后客户端进入 **SYN_SEND** 状态，等待服务端的确认；
   - **二次握手**:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端,然后服务端进入 **SYN_RECV** 状态；
   - **三次握手**:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，然后客户端和服务端都进入**ESTABLISHED** 状态，完成 TCP 三次握手。

   当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！

10. **第一次挥手**：客户端发送一个 FIN（SEQ=x） 标志的数据包->服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 **FIN-WAIT-1** 状态。

    **第二次挥手**：服务端收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包->客户端 。然后服务端进入 **CLOSE-WAIT** 状态，客户端进入 **FIN-WAIT-2** 状态。

    **第三次挥手**：服务端发送一个 FIN (SEQ=y)标志的数据包->客户端，请求关闭连接，然后服务端进入 **LAST-ACK** 状态。

    **第四次挥手**：客户端发送 ACK (ACK=y+1)标志的数据包->服务端，然后客户端进入**TIME-WAIT**状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 **2MSL** 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。

---

操作系统

1. 有了进程为什么还需要线程

   进程切换开销大于线程

   线程更加轻量，一个进程可以创建多个线程

   **多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。**而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。

   **同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核**
   
2. 线程如何进行数据通信

   共享内存

   信号量

   互斥锁

3. 死锁  **A在占有资源1的同时需要资源2 ，B在占有资源2的同事需要资源1**

   四个必要条件 **1. 互斥条件 2. 占有和等待 3. 不可抢占 4. 循环等待**

   解决方法 **银行家算法 请求某资源时，先试探释放资源，判断该方法是否安全**

4. 学一下Go语言

----

SpringBoot

1. 循环依赖 两个bean互相依赖 三个依赖 三角依赖的关系都会构成循环依赖

   - 加入二级缓存 并利用java的引用传递，

     创建A

     ​	空的A加入缓存， **提前暴露**

     ​	调用b时，b还没有被创建，

     ​	创建b，创建b需要A，

     ​			从缓存中获取A并赋值，

     ​	b创建成功，

     A也创建成功

   - 三级缓存 应对AOP情况 **提前AOP**

   - 实际业务开发很少出现情况，通过**分层设计**，每一层负责特定的功能，例如表现层（控制层），业务层，持久层，只允许更高层调用更底层代码，确保系统各个部分的代码逻辑是单向的，避免了循环依赖

2. **IOC 控制反转** 将对象之间的依赖关系交给IOC容器管理，本质是一个Map对象

   IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。

3. AOP

   旨在将跨越多个模块或类的**通用功能**（如日志记录、权限控制、事务管理等）进行分离，减少代码重复，并保持核心业务逻辑的简洁性。

4. SpringBoot 和Spring MVC的区别

   1. Spring MVC 是基于Spring的一个 **MVC 框架**；
   2. Spring Boot 是基于Spring4的条件注册的一套**快速开发整合包。** 它集成了**大量常用的第三方库配置(例如Jackson, JDBC, Mongo, Redis, Mail**等等)

---

Mysql

1. 存储引擎 
   - innoDB  支持事务
   - MyISAM
2. innoDB与MyISAM的区别
3. 事务是什么

----

Redis

