# 个人面试100题

1. java HashMap底层

   1、简介：Java中的HashMap是一种基于哈希表的Map接口实现。它可以存储键值对，并且支持快速的插入、删除和查找操作。 2、使用的数据结构：HashMap的底层实现是数组+链表/红黑树。 3、具体实现原理： 1.创建结构：HashMap内部维护了一个Entry数组，每个Entry包含一个键值对。 

   2.插入值：HashMap根据键的哈希值计算出该键值对在数组中的位置。如果该位置已经有其他键值对了，则使用链表或红黑树来解决冲突。

    3.查找值：HashMap会根据键的哈希值计算出该键值对在数组中的位置，然后遍历链表或红黑树，找到对应的键值对。 

   4.查找效率优化：Java 8中，当链表长度超过一定阈值时，会将链表转换为红黑树，以提高查找效率。 

   5.存储、访问效率优化：通过动态扩容、负载因子等特性提高效率。 

2. java HashSet

   java中HashSet的底层实现是HashMap，HashSet只考虑key的值，value都指向同一个全局object常量，这样就实现了HashSet。 比较过程： 1.通过哈希算法比较哈希值 2.哈希值相等再比较equals 

3. 设计模式 

   设计模式是可复用的解决方案，用于解决在软件开发过程中常见的设计问题，以提高代码的可维护性、可扩展性和灵活性

4. 装饰模式和代理模式

   装饰模式：
   装饰模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。主要是对原始类功能进行增强，支持多个装饰器的嵌套使用

   代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能**，这是它跟装饰器模式最大的不同。**主要增强的是非主干或者说非业务性的功能

5. 委派模式和策略模式

   老板（Boss）给项目经理（Leader）下达任务，项目经理会根据实际情况给每个员工派发工作任务，待员工把工作任务完成之后，再由项目经理汇报工作进度和结果给老板

   指负责任务的调度和分配任务，跟代理模式很像，可以看做是一种特殊情况下的静态代理的全权代理，但是代理模式注重过程，而委派模式注重结果。

----

计算机网络

6. http状态码

   **1XX** Infommational(信息性状态码)   接收的请求正在处理
   **2XX**Success(成功状态码)                   请求正常处理完毕
   **3XX** Redirection(重定向状态码)         需要进行附加操作以完成请求
   **4XX** Client Error(客户端错误状态码)  服务器无法处理请求
   **5xx** Server Eror(服务器错误状态码)  服务器处理请求出错

7. http header

   **请求部分**

   accept 能够接受的回应内容类型

   accept-charset

   accept-lauguage

   accept-Encoding

   Authorization 授权信息

   Cache-Control 用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令

   **响应部分**

   Connection 该浏览器想要优先使用的连接类型

   Content

   Content-Length 以八位字节数组（8 位的字节）表示的**请求体**的长度

   Content-MD5 请求体的内容的二进制 MD5 散列值，以 Base64 编码的结果

   Content-Type 请求体的多媒体类型（用于 POST 和 PUT 请求中）

   Cookie  之前由服务器通过 Set-Cookie（下文详述）发送的一个超文本传输协议 Cookie

   Date 发送该消息的日期和时间

   From 发起此请求的用户的邮件地址

   **Server**: 包含服务器的应用程序信息。

   **Location**: 用于重定向请求时的目标 URL

   **Access-Control-Allow-Origin**: 指定允许跨域访问的来源

8. get post请求

   语义（主要区别）：GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。

   幂等：GET 请求是幂等的，即多次重复执行不会改变资源的状态，而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。

   格式：GET 请求的参数通常放在 URL 中，形成查询字符串（querystring），而 POST 请求的参数通常放在请求体（body）中，可以有多种编码格式，如 application/x-www-form-urlencoded、multipart/form-data、application/json 等。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的 body 大小则没有明确的限制。不过，实际上 GET 请求也可以用 body 传输数据，只是并不推荐这样做，因为这样可能会导致一些兼容性或者语义上的问题。

   缓存：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。而 POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。

   安全性：GET 请求和 POST 请求如果使用 HTTP 协议的话，那都不安全，因为 HTTP 协议本身是明文传输的，必须使用 HTTPS 协议来加密传输数据。另外，GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中。

9. 三次握手 四次挥手

   - **一次握手**:客户端发送带有 SYN（SEQ=x） 标志的数据包 -> 服务端，然后客户端进入 **SYN_SEND** 状态，等待服务端的确认；
   - **二次握手**:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端,然后服务端进入 **SYN_RECV** 状态；
   - **三次握手**:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，然后客户端和服务端都进入**ESTABLISHED** 状态，完成 TCP 三次握手。

   当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！

10. **第一次挥手**：客户端发送一个 FIN（SEQ=x） 标志的数据包->服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 **FIN-WAIT-1** 状态。

    **第二次挥手**：服务端收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包->客户端 。然后服务端进入 **CLOSE-WAIT** 状态，客户端进入 **FIN-WAIT-2** 状态。

    **第三次挥手**：服务端发送一个 FIN (SEQ=y)标志的数据包->客户端，请求关闭连接，然后服务端进入 **LAST-ACK** 状态。

    **第四次挥手**：客户端发送 ACK (ACK=y+1)标志的数据包->服务端，然后客户端进入**TIME-WAIT**状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 **2MSL** 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。

---

操作系统

1. 有了进程为什么还需要线程

   进程切换开销大于线程

   线程更加轻量，一个进程可以创建多个线程

   **多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。**而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。

   **同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核**

----

SpringBoot

1. IOC 控制反正 将对象之间的依赖关系交给IOC容器管理，本质是一个Map对象

   ​	IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。

2. AOP

