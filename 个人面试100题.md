# 个人面试100题

**Java集合**

1. java HashMap底层

   - 基于哈希表的数据结构，用于存储键值对，通过哈希值来映射到数组的索引位置，通过数组➕链表来处理哈希冲突
   - 当链表长度超过8之后，会使用红黑树来代替链表，形成数组➕红黑树的结构来处理哈希冲突，红黑树是一种自平衡二叉树，能够将最坏情况时间复杂度从O(n)降低为O(Logn)
   - 性能提升 通过修改负载因子等方法
   - 哈希冲突 链地址法
   
2. java HashSet

   java中HashSet的底层实现是HashMap，HashSet只考虑key的值，value都指向同一个全局object常量，这样就实现了HashSet。 比较过程： 1.通过哈希算法比较哈希值 2.哈希值相等再比较equals 

---

**Java 多线程**

1. volatile关键字作用
   - 保证线程可见性 当字段被修改时，立即更新
   - 防止指令重排序（代码重排序）

2. 死锁

---

**设计模式** 

设计模式是**可复用的解决方案**，用于解决在软件开发过程中常见的设计问题，以提高代码的**可维护性、可扩展性和灵活性**

1. 单例模式：

   - 确保类只有一个实例，提供一个全局访问点，例如Windows任务管理器
   - 2种实现模式、饿汉模式，在类加载时就进行实例化、本身就安全;通过 ‘ a.getInstance()’调用
   - 懒汉模式 调用时才进行实例化、效率高于饿汉模式 判断是否为空

2. 装饰模式和代理模式
   **装饰模式**在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。主要是对原始类功能进行增强，支持多个装饰器的嵌套使用

   **代理模式**在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能**，这是它跟装饰器模式最大的不同。**主要增强的是非主干或者说非业务性的功能

3. 委派模式和策略模式

   老板（Boss）给项目经理（Leader）下达任务，项目经理会根据实际情况给每个员工派发工作任务，待员工把工作任务完成之后，再由项目经理汇报工作进度和结果给老板

   只负责任务的调度和分配任务，跟代理模式很像，可以看做是一种特殊情况下的静态代理的全权代理，但是代理模式注重过程，而委派模式注重结果。

----

**计算机网络**

6. http状态码

   **1XX** Infommational(信息性状态码)   接收的请求正在处理
   **2XX**Success(成功状态码)                   请求正常处理完毕
   **3XX** Redirection(重定向状态码)         **需要进行附加操作以完成请求**
   **4XX** Client Error(客户端错误状态码)  服务器无法处理请求
   **5xx** Server Eror(服务器错误状态码)  服务器处理请求出错

7. http header

   **请求部分**

   accept 能够接受的回应内容类型

   accept-charset

   accept-lauguage

   accept-Encoding

   Authorization 授权信息

   Cache-Control 用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令

   **响应部分**

   Connection 该浏览器想要优先使用的连接类型

   Content

   Content-Length 以八位字节数组（8 位的字节）表示的**请求体**的长度

   Content-MD5 请求体的内容的二进制 MD5 散列值，以 Base64 编码的结果

   Content-Type 请求体的多媒体类型（用于 POST 和 PUT 请求中）

   Cookie  之前由服务器通过 Set-Cookie（下文详述）发送的一个超文本传输协议 Cookie

   Date 发送该消息的日期和时间

   From 发起此请求的用户的邮件地址

   **Server**: 包含服务器的应用程序信息。

   **Location**: 用于重定向请求时的目标 URL

   **Access-Control-Allow-Origin**: 指定允许跨域访问的来源

8. get post请求

   语义（主要区别）：GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。

   幂等：GET 请求是幂等的，即多次重复执行不会改变资源的状态，而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。

   格式：GET 请求的参数通常放在 URL 中，形成查询字符串（querystring），而 POST 请求的参数通常放在请求体（body）中，可以有多种编码格式，如 application/x-www-form-urlencoded、multipart/form-data、application/json 等。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的 body 大小则没有明确的限制。不过，实际上 GET 请求也可以用 body 传输数据，只是并不推荐这样做，因为这样可能会导致一些兼容性或者语义上的问题。

   缓存：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。而 POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。

   安全性：GET 请求和 POST 请求如果使用 HTTP 协议的话，那都不安全，因为 HTTP 协议本身是明文传输的，必须使用 HTTPS 协议来加密传输数据。另外，GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中。

9. 三次握手 四次挥手

   - **一次握手**:客户端发送带有 SYN（SEQ=x） 标志的数据包 -> 服务端，然后客户端进入 **SYN_SEND** 状态，等待服务端的确认；
   - **二次握手**:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端,然后服务端进入 **SYN_RECV** 状态；
   - **三次握手**:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，然后客户端和服务端都进入**ESTABLISHED** 状态，完成 TCP 三次握手。

   当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！

10. **第一次挥手**：客户端发送一个 FIN（SEQ=x） 标志的数据包->服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 **FIN-WAIT-1** 状态。

    **第二次挥手**：服务端收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包->客户端 。然后服务端进入 **CLOSE-WAIT** 状态，客户端进入 **FIN-WAIT-2** 状态。

    **第三次挥手**：服务端发送一个 FIN (SEQ=y)标志的数据包->客户端，请求关闭连接，然后服务端进入 **LAST-ACK** 状态。

    **第四次挥手**：客户端发送 ACK (ACK=y+1)标志的数据包->服务端，然后客户端进入**TIME-WAIT**状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 **2MSL** 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。

---

操作系统

1. 有了进程为什么还需要线程

   进程切换开销大于线程

   线程更加轻量，一个进程可以创建多个线程

   **多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。**而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。

   **同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核**
   
2. 线程如何进行数据通信

   共享内存

   信号量

   互斥锁

3. 死锁  **A在占有资源1的同时需要资源2 ，B在占有资源2的同事需要资源1**

   四个必要条件 **1. 互斥条件 2. 占有和等待 3. 不可抢占 4. 循环等待**

   解决方法 **银行家算法 请求某资源时，先试探释放资源，判断该方法是否安全**

4. 学一下Go语言

----

SpringBoot

1. 循环依赖 两个bean互相依赖 三个依赖 三角依赖的关系都会构成循环依赖

   - 加入二级缓存 并利用java的引用传递，

     创建A

     ​	空的A加入缓存， **提前暴露**

     ​	调用b时，b还没有被创建，

     ​	创建b，创建b需要A，

     ​			从缓存中获取A并赋值，

     ​	b创建成功，

     A也创建成功

   - 三级缓存 应对AOP情况 **提前AOP**

   - 实际业务开发很少出现情况，通过**分层设计**，每一层负责特定的功能，例如表现层（控制层），业务层，持久层，只允许更高层调用更底层代码，确保系统各个部分的代码逻辑是单向的，避免了循环依赖

2. **IOC 控制反转** 将对象之间的依赖关系交给IOC容器管理，本质是一个Map对象

   IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。

3. AOP

   旨在将跨越多个模块或类的**通用功能**（如日志记录、权限控制、事务管理等）进行分离，减少代码重复，并保持核心业务逻辑的简洁性。

4. SpringBoot 和Spring MVC的区别

   1. Spring MVC 是基于Spring的一个 **MVC 框架**；
   2. Spring Boot 是基于Spring4的条件注册的一套**快速开发整合包。** 它集成了**大量常用的第三方库配置(例如Jackson, JDBC, Mongo, Redis, Mail**等等)

---

**Mysql**

1. mysql最大存储限制

   每行的最大大小为 **16KB**，但可以通过溢出页存储大字段（如 `BLOB` 或 `TEXT`）来突破此限制。

2. 存储引擎

   - innoDB  支持事务
   - MyISAM

3. innoDB与MyISAM的区别 实际应用中几乎不存在使用MyISAM的理由了

   1. 是否支持**行级锁**
   2. 是否支持事务
   3. 是否支持外键 但都不推荐使用
   4. 是否支持数据库异常崩溃后的安全恢复
   5. 是否支持 MVCC
   6. 索引实现不一样
   7. **性能有差别**
   8. 数据缓存策略和机制实现不同

4. 锁

   1. 行级锁 锁粒度小，并发度高 开销大
   2. 表级锁  对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快

5. 事务是什么？ 结合场景

   **事务是逻辑上的一组操作，要么都执行，要么都不执行**

   例子就是**转账**了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。

   1. 将小明的余额减少 1000 元
   2. 将小红的余额增加 1000 元。

6. ACID原则

   A 原子性

   C 一致性

   I **隔离性** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的

   D 持久性

7. 并发事务带来的问题

   1. 脏读
   2. 丢失修改 
   3. 不可重复读 
   4. 幻读 不可重复读的一种特殊情况

8. 解决方法

   1. 不可重复读 加锁
   2. 幻读，由于加锁只能锁住已有的数据 例如delete和update时，对记录加锁，保证事务的安全，而insert操作产生新的数据，所以是一种特殊情况，需要通过增加**间隙锁**来保证不出现幻读的情况

9. 隔离级别

   |        隔离级别         | 脏读 | 不可重复读 | 幻读 |
   | :---------------------: | :--: | :--------: | :--: |
   |    READ-UNCOMMITTED     |  √   |     √      |  √   |
   |     READ-COMMITTED      |  ×   |     √      |  √   |
   | REPEATABLE-READ（默认） |  ×   |     ×      |  √   |
   |      SERIALIZABLE       |  ×   |     ×      |  ×   |

10. Mysql性能优化有哪些方式

    1. 优化sql语句
    2. 索引优化
    3. 分库分表

11. Mysql 规范

    1. https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html

12. 谈谈你是如何优化sql查询速度的

    1. **找到瓶颈 **利用性能监控工具定位慢sql，**MySQL 慢查询日志**、**Performance Schema** 

    2. 索引优化 、表结构优化、sql语句的优化

    3. 架构优化

       1. **读写分离**

       将读操作和写操作分离到不同的数据库实例，提升数据库的并发处理能力。

       2. **分库分表**

       将数据分散到多个数据库实例或数据表中，降低单表数据量，提升查询效率。但要权衡其带来的复杂性和维护成本，谨慎使用。

       3. **缓存机制 redis等等**

       4. **数据库冷热分离** 其引入的复杂性会带来额外的维护成本

       根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据高性能存储介质中。

13. 什么是索引

    是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构

14. 索引优缺点

    - 使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 减少 IO 次数，这也是创建索引的最主要的原因。

    - 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
    - 缺点
      - 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
      - 索引需要使用物理文件存储，也会耗费一定空间

15. 索引底层数据结构 **默认使用B+树**

    1. hash表
    2. 二叉查找树BST
    3. 自平衡树 AVL
    4. 红黑树
    5. B&B+树

16. B 树& B+树两者有何异同呢？

    - B 树的所有节点既存放键(key) 也存放数据(data)，而 **B+树只有叶子节点存放 key 和 data，其他内节点只存放 key**。
    - **B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。**
    - B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了**。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。**
    - 在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。

    综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。

​		

​			





----

Redis

